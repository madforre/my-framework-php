Docker

	도커는 명령어를 입력하는 도커 클라이언트와 
	백그라운드(docker daemon)로 요청을 대기중인 도커 서버로 나뉜다.

 - 기본값이 도커 서버의 소켓을 바라보고 있기 때문에 
  사용자는 의식하지 않고 마치 바로 명령을 내리는 것 같은 느낌을 받는다.
  이러한 설계가 mac이나 windows의 터미널에서 명령어를 입력했을때 
  가상 서버에 설치된 도커가 동작하는 이유입니다.

도커를 실행하는 명령어


 - 컨테이너 실행하기

	docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...]

 - 자주 사용하는 옵션

	-d	detached mode 흔히 말하는 백그라운드 모드
	-p	호스트와 컨테이너의 포트를 연결 (포워딩)
	-v	호스트와 컨테이너의 디렉토리를 연결 (마운트)
	-e	컨테이너 내에서 사용할 환경변수 설정
	–name	컨테이너 이름 설정
	–rm	프로세스 종료시 컨테이너 자동 제거
	-it	-i와 -t를 동시에 사용한 것으로 터미널 입력을 위한 옵션
	
Redis란?

	Remote Dictionary System의 약자로 쉽게 말하면
	인메모리 원격 캐시 서버 정도로 생각하면 된다.

	NoSQL DBMS로 분류할 수도 있고 인 메모리라는 특성 때문에
	in memory 솔루션으로 분류할 수도 있다

	* 즉 메모리를 이용하여 고속으로 <key, value> 스타일의 데이터를 저장하고
	불러올 수 있는 원격 시스템이다.

 - key 권장 사항 : 간결하면서도 중복되지 않아야 한다.
		   너무 긴 문자열은 지양하고 어쩔 수 없다면 해시(SHA1)를
		   이용해서 저장하기를 권고한다.
		   아주 작은 차이라서 가독성을 해치는 것보단 적절히 사용하는게
		   낫다.

 - Value format : string, lists, sets(중복 불가능한 리스트)
		  , sorted sets(추가로 score 저장), 
		   hashes( field 와 value를 가진 구조)

 - value 권장 사항 : hashes 하나의 key에 40억개 정도 값 저장 가능하지만,
	             성능상의 이유로 이렇게 많이 저장하면 안된다.

 - Expire 설정 : 만료시간을 정할 수 있다. (제한된 메모리를 위함)

* 가상머신에서는 성능의 한계가 있기 때문에 일반 리눅스 서버에서 설치하고
  사용하기를 권장한다.

워드프레스 컨테이너

	- 워드프레스 컨테이너 내부에는 apache2 와 php가 설치되어 있지만 
	  추상화되어 실행과정에선 드러나지 않는다.

tensorflow

	- 손쉽게 머신러닝을 할 수 있는 툴이다.

	docker run -d -p 8888:8888 -p 6006:6006 teamlab/pydata-tensorflow:0.1

	teamlab/pydata-tensorflow:0.1 이 이미지는
	numpy, scipy, pandas, jupyter, scikit-learn, gensim,
	BeautifulSoup4, Tensorflow가 설치되어 있음

-----------------------------------------------------

도커 명령어

docker ps [OPTIONS]

	docker ps : 실행중인 컨테이너 목록을 보여준다.
	docker ps -a : 종료된 컨테이너도 목록에 추가로 보여준다.

docker stop container_id - 실행중인 컨테이너 중지

docker pull image_name:version

	- 이미지 다운로드하기(pull) 

docker rmi [OPTIONS] IMAGE [IMAGE...]

	- images 명령어를 통해 얻은 이미지 목록에서 이미지 ID를 입력하면
	  삭제가 된다. 단, 컨테이너가 실행중인 이미지는 삭제되지 않는다.

	이미지는 여러개의 레이어로 구성되어 있기 때문에 모든 레이어가
	삭제된 것을 알 수 있다.


docker logs --tail 10 ${WORDPRESS_CONTAINER_ID}

	워드프레스 컨테이너 ID를 입력하면 마지막 10줄 로그 출력

docker logs -f ${WORDPRESS_CONTAINER_ID}

	실시간으로 로그 생성 확인

	컨테이너의 로그파일은 json 방식으로 어딘가에 저장이 됩니다. 
	로그가 많으면 은근히 파일이 차지하는 용량이 커지므로 주의해야합니다. 
	도커는 다양한 플러그인을 지원하여 json이 아닌 특정 로그 서비스에 
	스트림을 전달할 수 있습니다. 

	* 기본 logging driver를 사용하면 로그가 계속 쌓이게 된다.

	* 어느 정도 앱의 규모가 커지면 기본적인 방식 대신 
	  로그 서비스를 이용하는 걸 고려해야 합니다.

docker exec [OPTIONS] CONTAINER COMMAND [ARG...]

	컨테이너를 관리하다 보면 실행중인 컨테이너에 들어가보거나 
	컨테이너의 파일을 실행하고 싶을 때가 있다.
	이럴때 사용한다.

	* docker run ~ 컨테이너 실행 명령과 차이점?

		run은 새로 컨테이너를 만들어서 실행하고 
		exec는 실행중인 컨테이너에 명령어를 내린다.

	* 도커 옵션 : -it -i와 -t를 동시에 사용한 것으로 터미널 입력을 위한 옵션

		      키보드 입력이 필요하면 -it 옵션을 주도록 하자.

	굳이 복잡한 작업이 필요 없는 경우는 -it 옵션없이 단순하게 명령을
	실행하고 종료할 수 있다.

중요 - 컨테이너를 삭제한다는 건 컨테이너에서 생성된 파일이 사라진다는 것을 뜻한다.
	따라서 컨테이너 삭제시 유지해야하는 데이터는 반드시
  	컨테이너 내부가 아닌 외부 스토리지에 저장해야 한다.

	가장 좋은 방법은 AWS S3같은 클라우드 서비스이고,
	또 하나는 데이터 볼륨(Data volumes)을 컨테이너에 추가해서
	사용하는 것이다.

	데이터 볼륨을 사용하면 해당 디렉토리는 컨테이너와 별도로 저장되고
	컨테이너를 삭제해도 데이터가 지워지지 않는다.

- ':' 는 호스트와 컨테이너 간의 맵핑을 의미하는거 같은데 
  연결해주는 역할인 듯 하다.

	ex) 3306:3306
	
* 아래 명령어처럼 호스트의 디렉토리를 볼륨으로 사용하면
  컨테이너를 삭제해도 데이터는 사라지지 않는다!
  다시 컨테이너를 실행할 때 동일한 디렉토리를 마운트 한다면
  그대로 데이터를 사용할 수 있다.
	
	docker run -d -p 3306:3306 \
	  -e MYSQL_ALLOW_EMPTY_PASSWORD=true \
	  --name mysql \
	  -v /my/own/datadir:/var/lib/mysql \ # 볼륨 마운트하는 부분
	 mysql:5.7


컨테이너는 삭제 후 새로 만들면 모든 데이터가 초기화됨
업로드 파일을 외부 스토리지와 링크하여 사용하거나 S3같은 별도의 저장소가 필요
세션이나 캐시를 파일로 사용하고 있다면 memcached나 redis와 같은 외부로 분리

----------------------------------------------------

Docker-Compose yml

build : 빌드시 적용되는 구성 옵션


*** 데이터 볼륨 설정을 통해 컨테이너끼리 데이터를 공유할 수 있다! ***

* docker exec 는 container 내부에 명령을 내리는 명령어이다.


------------------------------------------

디폴트 도커 네트워크

도커를 처음 설치하면 세 가지 종류의 네트워크가 자동으로 설정된다. 
이름은 none, host, bridge다. none과 host 네트워크는 삭제가 불가능하다. 
도커 네트워크 스택의 일부이기 때문이다. 
하지만 네트워크 담당자에게 있어서 이 두 가지 네트워크는 그다지 유용한 것이 아니다. 
따로 설정을 가할 수 있을만한 외부 인터페이스가 없기 때문이다. 
하지만 bridge 네트워크는 관리자가 설정을 할 수 있다. 
bridge 네트워크는 docker0 네트워크라고 하기도 한다. 

bridge 혹은 docker0 네트워크는 자동으로 IP 서브넷과 게이트웨이를 생성한다. 
이 네트워크에 속한 모든 콘테이너들은 같은 서브넷에도 속하게 된다. 
그러므로 bridge 네트워크 내에서 일어나는 콘테이너들 사이의 모든 통신은 
IP 주소 할당을 통하여 발생하게 된다.

자, 그럼 이런 디폴트 브리지 네트워크를 그대로 사용하면 될까? 되긴 되지만 한 가지 단점이 있다. 
DNS를 사용해 자동으로 서비스를 찾아주는 기능이 비활성화되어 있다는 것이다. 
이 디폴트 네트워크 내의 콘테이너들이 통신을 할 수 있도록 하려면 —link라는 옵션을 사용해야만 한다. 
여기에 더해 포트 포워딩을 해야만 콘테이너들 간 통신이 발생할 수 있으니, 이 역시 알아두자.

도커를 시도해본 많은 관리자들이 이러한 점 때문에 ‘콘테이너는 네트워크 사용성과 확장성에 큰 장애가 된다’고 생각한다. 
사실 디폴트만 사용한다면 그렇게 느껴질 공산이 다분하다. 그래서 사용자가 정의한 네트워크를 사용하는 편을 권장한다. 
그렇게 하면 통신을 원활히 해야 하는 콘테이너의 활용과 관리가 더 쉬워진다.

사용자 정의 네트워크의 유형

	도커는 자동으로 생성되는 네트워크 외에 다양한 종류의 네트워크를 사용자가 정의해서 사용할 수 있도록 하고 있다. 
	또한 사용자가 정의한 네트워크에 콘테이너를 추가하는 것도 가능하다. 

	여기서 기억해야 할 건 같은 네트워크에 있는 콘테이너들끼리는 얼마든지 통신이 가능하지만 
	다른 네트워크에 있는 콘테이너들끼리는 불가능하다는 것이다. 
	하지만 콘테이너를 사용하다보면 다른 네트워크와의 통신이 필요할 때가 있다. 이럴 때는 해당 콘테이너를 여러 네트워크에 추가하면 간단히 해결된다. 

사용자가 정의할 수 있는 네트워크에는 크게 세 가지 종류가 존재한다. 

	1) bridge 네트워크 : 디폴트에서 자동으로 생성해주는 bridge 네트워크와 비슷하다. IP 서브넷과 게이트웨이를 독립적으로 보유하고 있다는 점이 그렇다. 
			     하지만 사용자가 정의한 bridge 네트워크의 콘테이너들은 포트 포워딩을 하지 않아도 서로 통신을 할 수 있다는 점에서 차이가 있다. 
			     게다가 DNS를 활용한 자동 서비스 검색 기능이 완벽히 호환되기도 한다. 
			     당신이 정의한 bridge 네트워크 내의 자산과 다른 네트워크에 연결된 기기들과 소통을 하게 하려면 간단히 TCP/UDP 포트를 필요에 따라 열면 된다. 
			     도커가 해당 네트워크 주소와 포트를 외부 네트워크에 공개할 것이다.

	2) overlay 네트워크 : 분산된 네트워크에서 도커를 사용해야 할 때가 있다. 여러 호스트에 설치된 콘테이너들끼리 직접 통신을 해야만 하는 상황이다. 
				그럴 때는 overlay 네트워크가 해결책이다. 그러려면 먼저 도커 서버들의 swarm mode가 활성화되어 있어야 한다. 
				swarm mode란 도커가 도커 엔진 다수(이를 swarm이라고 한다)를 관리할 수 있도록 해주는 방법이다. 
				이 모드를 활성화시켰다면 VXLAN 캡슐화를 사용해 layer 2 overlay 네트워크를 swarm 안에 만드는 게 가능해진다. 
				그런 후에 콘테이너를 overlay 네트워크에 추가하면 마치 모든 콘테이너가 같은 노드 안에 있는 것처럼 서로 간 직접 통신이 가능해진다. 
				외부에서 overlay 네트워크와 통신을 할 수 있도록 하려면 사용자가 정의한 bridge 네트워크에서처럼 설정하면 된다.

	3) macvlan 네트워크 : macvlan 네트워크는 bridge 네트워크와 overlay 네트워크를 사용할 때 콘테이너와 호스트 사이의 브리지를 제거함으로써 
				콘테이너 통신을 간단하고 보다 원활하게 만드는 네트워크다. 
				macvlan 네트워크를 사용할 때 얻을 수 있는 이점은 네트워크 바깥 면을 향해야 하는 콘테이너 자산을 외부 네트워크에 
				포트 포워딩 없이 연결시킬 수 있다는 것이다. ‘layer 3 IP 할당’ 대신 ‘layer 2 MAC 주소’를 사용하기에 가능한 일이다.

-------------------

일반적으로 레이어 2는 브로드 캐스트 MAC 레벨 네트워크이고, 레이어 3은 IP 네트워크를 통한 세그먼트 라우팅입니다

-------------------

현재 기준 안정적이면서 상용화 가능한 Docker Platform은 linux 64bit
윈도우, os x 사용자는 VM 안에서 Docker 실행가능
BSD, solaris, 윈도우 서버 등과 같은 다른 플랫폼의 네이티브 컨테이너에 대한 지원은 각기 다른 단계에서 개발 진행
Docker는 기본적으로 가상화 관련 작업 하지 않음 그래서 container는 호스트 커널과 항상 일치해야 함
(윈도우 서버 container는 윈도우 서버 호스트에서만 실행, 64bit linux container는 64bit linux 호스트에서만 실행 가능)

-------------------

1. 호스트에서 컨테이너로 파일 전송하는 방법

docker cp /path/foo.txt mycontainer:/path/foo.txt



2. 컨테이너에서 호스트로 파일 전송하는 방법 

docker cp mycontainer:/path/foo.txt /path/foo.txt

------------------

EXPOSE는 호스트와 연결만 할 뿐 외부에 노출은 되지 않습니다.